#! /usr/bin/env elixir
{:ok, input_content} = System.argv() |> Enum.at(0) |> File.read()

defmodule Tetris do
    def fill_floor(xrange),         do: for x     <- xrange, do: :ets.insert_new(:chamber, {{x,0}, :floor})
    def fill_wall(x, yrange),       do: for y     <- yrange, do: :ets.insert_new(:chamber, {{x,y}, :wall})
    def land_rocks(rocks),          do: for {x,y} <- rocks,  do: true = :ets.insert_new(:chamber, {{x,y}, :rock})
    def move_rocks(rocks, {dx,dy}), do: for {x,y} <- rocks,  do: {x+dx,y+dy}

    def fill_walls(xrange, yrange) do
        for y <- yrange, do: :ets.insert(:chamber, {{xrange.first, y}, :wall})
        for y <- yrange, do: :ets.insert(:chamber, {{xrange.last,  y}, :wall})
    end

    def can_move?(rocks, {dx,dy}) do
        Enum.all?(rocks, fn {x,y} ->
            not :ets.member(:chamber, {x+dx,y+dy})
        end)
    end

    def top(rocks) do
        rocks |> Enum.map(&(elem(&1, 1))) |> Enum.min()
    end

    def drop_rock(xrange, yrange, shape, stream) do
        {xstart, ystart} = elem(shape, 1)

        xstart = xstart + xrange.first + 1
        ystart = ystart + yrange.first

        # IO.inspect({xstart,ystart}, label: "Start Pos")

        rocks = move_rocks(elem(shape, 2), {xstart,ystart})

        wall_yrange = top(rocks)..(yrange.first-1)
        fill_wall(xrange.first, wall_yrange)
        fill_wall(xrange.last,  wall_yrange)

        drop_rock_loop(rocks, stream, [])
    end

    defp decode_dir(?<), do: {-1,0}
    defp decode_dir(?>), do: {+1,0}

    defp drop_rock_loop(rocks, [], revstream) when length(revstream) > 0 do
        # repeate stream
        drop_rock_loop(rocks, Enum.reverse(revstream), [])
    end
    defp drop_rock_loop(rocks, [char|stream], revstream) do
        dir = decode_dir(char)
        rocks = case can_move?(rocks, dir) do
            true  ->
                # IO.inspect(dir, label: "Moved")
                move_rocks(rocks, dir)
            false ->
                # IO.inspect(dir, label: "Nothing")
                rocks
        end

        down = {0, +1}
        case can_move?(rocks, down) do
            true ->
                rocks = move_rocks(rocks, down)
                drop_rock_loop(rocks, stream, [char|revstream])
            false ->
                land_rocks(rocks)
                {rocks, stream ++ Enum.reverse([char|revstream])}
        end
    end

    def draw_chamber(xrange, yrange) do
        screen = Enum.map(yrange, fn y ->
            Enum.map(xrange, fn x ->
                case :ets.lookup(:chamber, {x,y}) do
                    [] -> ?.
                    [{{^x,^y}, :floor}] -> ?-
                    [{{^x,^y}, :rock}]  -> ?#
                    [{{^x,^y}, :wall}]  -> ?|
                end
            end) ++ '\n'
        end)
        :io.format(screen)
    end
end

shapes = [
    {:hbar, {2,-4}, [{0,0},{1,0},{2,0},{3,0}]},
    {:plus, {2,-4}, [{1,0},{0,-1},{1,-1},{2,-1},{1,-2}]},
    {:revl, {2,-4}, [{0,0},{1,0},{2,0},{2,-1},{2,-2}]},
    {:vbar, {2,-4}, [{0,0},{0,-1},{0,-2},{0,-3}]},
    {:quad, {2,-4}, [{0,0},{0,-1},{1,0},{1,-1}]},
]

stream = String.to_charlist(input_content)
xrange = 0..8
yrange = -0..+0

:chamber = :ets.new(:chamber, [:set, :private, :named_table])
Tetris.fill_floor(xrange)

result = Enum.reduce(0..2021, {xrange, yrange, shapes, stream}, fn n, {xrange, yrange, shapes, stream} ->
    {rocks, stream} = Tetris.drop_rock(xrange, yrange, Enum.at(shapes, rem(n, length(shapes))), stream)
    rocks_top      = Tetris.top(rocks)

    yrange = case rocks_top < yrange.first do
        true  -> rocks_top..yrange.last
        false -> yrange
    end

    # Tetris.draw_chamber(xrange,yrange)

    {xrange, yrange, shapes, stream}
end)

IO.inspect(abs(elem(result, 1).first), label: "Result")

# {landed_rocks, stream} = Tetris.drop_rock(xrange, yrange, Enum.at(shapes, 0), stream)
# landed_rocks_ymin      = Tetris.top(landed_rocks)
# 
# yrange = case landed_rocks_ymin < yrange.first do
#     true  -> landed_rocks_ymin..yrange.last
#     false -> yrange
# end
# 
# Tetris.draw_chamber(xrange,yrange)
# 
# {landed_rocks, stream} = Tetris.drop_rock(xrange, yrange, Enum.at(shapes, 1), stream)
# landed_rocks_ymin      = Tetris.top(landed_rocks)
# 
# yrange = case landed_rocks_ymin < yrange.first do
#     true  -> landed_rocks_ymin..yrange.last
#     false -> yrange
# end
# 
# Tetris.draw_chamber(xrange,yrange)
# 
# {landed_rocks, stream} = Tetris.drop_rock(xrange, yrange, Enum.at(shapes, 2), stream)
# landed_rocks_ymin      = Tetris.top(landed_rocks)
# 
# yrange = case landed_rocks_ymin < yrange.first do
#     true  -> landed_rocks_ymin..yrange.last
#     false -> yrange
# end

# Tetris.draw_chamber(xrange,yrange)